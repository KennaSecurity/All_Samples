# frozen_string_literal: true

require 'rest-client'
require 'json'
require 'csv'
require 'mail'

# These are the arguments we are expecting to get
@token = ARGV[0]
@csv_file = ARGV[1]
@include_solution = ARGV[2]
@send_email = ARGV[3] # true or false. if false no other params needed
@mail_server = @send_email == 'true' ? ARGV[4] : ''
@port = @send_email == 'true' ? ARGV[5] : ''
@user_name = @send_email == 'true' ? ARGV[6] : ''
@password = @send_email == 'true' ? ARGV[7] : ''
from_address = @send_email == 'true' ? ARGV[8] : ''

# Variables we'll need later
@base_url = 'https://api.kennasecurity.com/'
# @ag_url = "#{base_url}asset_groups"
# @fixes_url = "#{base_url}fixes"
@bulk_url = "#{@base_url}data_exports"
@headers = { 'content-type' => 'application/json', 'X-Risk-Token' => @token }
start_time = Time.now
@output_filename = Logger.new("csv-extract-#{start_time.strftime('%Y%m%dT%H%M')}.txt")

@debug = false
@max_retries = 2

csv_headers = []

csv_headers += [
  'Risk Score',
  'CVSS Severity',
  'CVSS Threat',
  'Asset Locator',
  'Asset Hostname',
  'Asset IP Address',
  'Asset Tags',
  'Asset Priority',
  'Asset Risk Meter Score',
  'Vulnerability',
  'CVE Description',
  'Connector Source',
  'Port',
  'Last Seen',
  'Found',
  'Created',
  'Due Date',
  'Status',
  'Closed',
  'Identifiers',
  'Active Breach',
  'Has Exploit',
  'Top Priority',
  'Popular Target'
]
csv_headers << 'Solution' if @include_solution
csv_headers += [
  'Notes',
  'ID',
  'Scanner Score',
  'Has Malware',
  'Asset OS',
  'Asset ID'
]
csv_headers += [
  'Asset Owner'
]
puts csv_headers.length if @debug

num_lines = CSV.read(@csv_file).length
puts "Found #{num_lines} lines."

options = { address: @mail_server.to_s,
            port: @port,
            user_name: @user_name.to_s,
            password: @password.to_s,
            authentication: 'plain',
            enable_starttls_auto: true }

Mail.defaults do
  delivery_method :smtp, options
end

## Iterate through CSV
CSV.foreach(@csv_file, headers: true) do |row|
  current_line = $INPUT_LINE_NUMBER
  query = nil
  email_recipients = nil

  query = row[0]
  query_name = row[1]
  email_recipients = row[2]

  # q = "-tag:”Decom” AND -vulnerability_score:0"

  bulk_query_json_string = '{"asset": {"status": ["active"]}, "status": ["open"],'
  bulk_query_json_string += " \"q\":\"#{query}\", \"export_settings\": { \"format\": \"json\", "
  bulk_query_json_string = "#{bulk_query_json_string}\"compression\": \"gzip\", \"model\": \"vulnerability\" }}"

  bulk_query_json = JSON.parse(bulk_query_json_string)

  puts bulk_query_json.to_s
  begin
    query_response = RestClient::Request.execute(
      method: :post,
      url: @bulk_url,
      headers: @headers,
      payload: bulk_query_json
    )
    puts query_response if @debug
    query_response_json = JSON.parse(query_response.body)
    searchID = query_response_json.fetch('search_id')
    # searchID = 1079331
    # puts "searchID = #{searchID}" if @debug
    output_results = "myoutputfile_#{searchID}.gz"
    searchComplete = false
    all_assets = []

    while searchComplete == false

      status_code = RestClient.get("#{@bulk_url}/status?search_id=#{searchID}", @headers).code

      puts "status code =#{status_code}" if @debug
      if status_code != 200
        puts 'sleeping for async query' if @debug
        sleep(60)
        next
      else
        puts 'ansyc query complete' if @debug
        searchComplete = true
        File.open(output_results, 'w') do |f|
          block = proc { |response|
            response.read_body do |chunk|
              f.write chunk
            end
          }
          RestClient::Request.new(method: :get, url: "#{@bulk_url}?search_id=#{searchID}", headers: @headers,
                                  block_response: block).execute
        end
        gzfile = open(output_results)
        gz = Zlib::GzipReader.new(gzfile)
        json_data = JSON.parse(gz.read)['vulnerabilities']
      end
    end

    filename = "#{query_name}_vulns_#{Time.now}.csv"

    CSV.open(filename, 'w') do |csv|
      csv << csv_headers

      json_data.each do |vuln|
        risk_score = nil
        cvss_severity = nil
        cvss_threat = nil
        asset_locator = nil
        asset_hostname = nil
        asset_ip_address = nil
        asset_tags = []
        asset_priority = nil
        asset_risk_meter_score = nil
        vulnerability = nil
        cve_description = nil
        connector_source = []
        port = nil
        last_seen = nil
        found = nil
        created = nil
        due_date = nil
        status = nil
        closed = nil
        identifiers = nil
        active_breach = nil
        has_exploit = nil
        solution = nil
        top_priority = nil
        popular_target = nil
        notes = nil
        id = nil
        scanner_score = nil
        has_malware = nil
        asset_os = nil
        asset_id = nil

        risk_score = vuln.fetch('risk_meter_score')
        cvss_severity = vuln.fetch('severity')
        cvss_threat = vuln.fetch('threat')
        vulnerability = vuln.fetch('cve_id')
        cve_description = vuln.fetch('description')
        vuln['connectors'].each do |conn|
          connector_source << conn.fetch('name')
        end
        port = vuln.fetch('port')
        last_seen = vuln.fetch('last_seen_time')
        found = vuln.fetch('first_found_on')
        created = vuln.fetch('created_at')
        due_date = vuln.fetch('created_at')
        status = vuln.fetch('status')
        closed = vuln.fetch('closed_at')
        identifiers = vuln.fetch('identifiers')
        active_breach = vuln.fetch('active_internet_breach')
        has_exploit = vuln.fetch('easily_exploitable')
        solution = vuln.fetch('solution') unless @include_solution == 'false'
        top_priority = vuln.fetch('top_priority')
        popular_target = vuln.fetch('popular_target')
        notes = vuln.fetch('notes')
        id = vuln.fetch('id')
        scanner_score = vuln.fetch('scanner_score')
        has_malware = vuln.fetch('malware_exploitable')
        asset_id = vuln.fetch('asset_id')

        a = []
        a = all_assets.find { |a| a[0] == asset_id }
        if a.nil?
          a = []
          asset_url = vuln['urls'].fetch('asset')
          asset_url = "https://#{asset_url}"
          puts "asset url= #{asset_url}" if @debug
          asset_return = RestClient::Request.execute(
            method: :get,
            url: asset_url,
            headers: @headers
          )

          asset_json = JSON.parse(asset_return.body)['asset']

          a << asset_id
          a << if asset_json.fetch('operating_system').nil?
                 ' '
               else
                 asset_json.fetch('operating_system')
               end
          a << if asset_json.fetch('ip_address').nil?
                 ' '
               else
                 asset_json.fetch('ip_address')
               end
          a << if asset_json.fetch('hostname').nil?
                 ' '
               else
                 asset_json.fetch('hostname')
               end
          a << if asset_json.fetch('locator').nil?
                 ' '
               else
                 asset_json.fetch('locator')
               end
          a << if asset_json.fetch('tags').nil?
                 ' '
               else
                 asset_json.fetch('tags')
               end
          a << if asset_json.fetch('priority').nil?
                 ' '
               else
                 asset_json.fetch('priority')
               end
          a << if asset_json.fetch('risk_meter_score').nil?
                 ' '
               else
                 asset_json.fetch('risk_meter_score')
               end
          a << if asset_json.fetch('owner').nil?
                 ' '
               else
                 asset_json.fetch('owner')
               end
          all_assets << a
        end

        asset_os = a[1]
        asset_ip_address = a[2]
        asset_hostname = a[3]
        asset_locator = a[4]
        asset_tags = a[5]
        asset_priority = a[6]
        asset_risk_meter_score = a[7]
        asset_owner = a[8]

        hold_row = []

        hold_row += [risk_score,
                     cvss_severity,
                     cvss_threat,
                     asset_locator,
                     asset_hostname,
                     asset_ip_address,
                     asset_tags.join(', '),
                     asset_priority,
                     asset_risk_meter_score,
                     vulnerability,
                     cve_description,
                     connector_source.join(', '),
                     port.join(', '),
                     last_seen,
                     found,
                     created,
                     due_date,
                     status,
                     closed,
                     identifiers.join(', '),
                     active_breach,
                     has_exploit,
                     top_priority,
                     popular_target]
        hold_row << solution if @include_solution
        hold_row += [
          notes,
          id,
          scanner_score,
          has_malware,
          asset_os,
          asset_id,
          asset_owner
        ]

        csv << hold_row
      end
    end

    if @send_email == 'true'
      Mail.deliver do
        to email_recipients.to_s
        from from_address.to_s
        subject "Vuln Report for #{query_name}"
        body "Vuln Report for #{query_name} - #{DateTime.now}"
        add_file filename: filename.to_s, content: File.read(filename)
      end

      File.delete(filename)
    end
  rescue RestClient::TooManyRequests => e
    retry
  rescue RestClient::UnprocessableEntity => e
    puts "unprocessible entity: #{e.message}"
  rescue RestClient::BadRequest => e
    @output_filename.error("Rest client BadRequest:...#{e.message} (time: #{Time.now}, start time: #{@start_time})")
    puts "BadRequest: #{e.backtrace.inspect}"
  rescue RestClient::Exception => e
    @retries ||= 0
    if @retries < @max_retries
      @retries += 1
      sleep(15)
      retry
    else
      @output_filename.error("General RestClient error... #{e.message}(time: #{Time.now}, start time: #{@start_time})")
      puts "Unable to get vulns: #{e.backtrace.inspect}"
    end
  rescue Exception => e
    @output_filename.error("General Exception:...#{e.message} (time: #{Time.now}, start time: #{@start_time})")
    puts "BadRequest: #{e.backtrace.inspect}"
  end
  File.delete(output_results)
end
